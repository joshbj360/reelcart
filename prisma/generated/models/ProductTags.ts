
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ProductTags` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model ProductTags
 * 
 */
export type ProductTagsModel = runtime.Types.Result.DefaultSelection<Prisma.$ProductTagsPayload>

export type AggregateProductTags = {
  _count: ProductTagsCountAggregateOutputType | null
  _avg: ProductTagsAvgAggregateOutputType | null
  _sum: ProductTagsSumAggregateOutputType | null
  _min: ProductTagsMinAggregateOutputType | null
  _max: ProductTagsMaxAggregateOutputType | null
}

export type ProductTagsAvgAggregateOutputType = {
  productId: number | null
  tagId: number | null
}

export type ProductTagsSumAggregateOutputType = {
  productId: number | null
  tagId: number | null
}

export type ProductTagsMinAggregateOutputType = {
  productId: number | null
  tagId: number | null
}

export type ProductTagsMaxAggregateOutputType = {
  productId: number | null
  tagId: number | null
}

export type ProductTagsCountAggregateOutputType = {
  productId: number
  tagId: number
  _all: number
}


export type ProductTagsAvgAggregateInputType = {
  productId?: true
  tagId?: true
}

export type ProductTagsSumAggregateInputType = {
  productId?: true
  tagId?: true
}

export type ProductTagsMinAggregateInputType = {
  productId?: true
  tagId?: true
}

export type ProductTagsMaxAggregateInputType = {
  productId?: true
  tagId?: true
}

export type ProductTagsCountAggregateInputType = {
  productId?: true
  tagId?: true
  _all?: true
}

export type ProductTagsAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProductTags to aggregate.
   */
  where?: Prisma.ProductTagsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductTags to fetch.
   */
  orderBy?: Prisma.ProductTagsOrderByWithRelationInput | Prisma.ProductTagsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ProductTagsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductTags from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductTags.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ProductTags
  **/
  _count?: true | ProductTagsCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: ProductTagsAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: ProductTagsSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ProductTagsMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ProductTagsMaxAggregateInputType
}

export type GetProductTagsAggregateType<T extends ProductTagsAggregateArgs> = {
      [P in keyof T & keyof AggregateProductTags]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateProductTags[P]>
    : Prisma.GetScalarType<T[P], AggregateProductTags[P]>
}




export type ProductTagsGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ProductTagsWhereInput
  orderBy?: Prisma.ProductTagsOrderByWithAggregationInput | Prisma.ProductTagsOrderByWithAggregationInput[]
  by: Prisma.ProductTagsScalarFieldEnum[] | Prisma.ProductTagsScalarFieldEnum
  having?: Prisma.ProductTagsScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ProductTagsCountAggregateInputType | true
  _avg?: ProductTagsAvgAggregateInputType
  _sum?: ProductTagsSumAggregateInputType
  _min?: ProductTagsMinAggregateInputType
  _max?: ProductTagsMaxAggregateInputType
}

export type ProductTagsGroupByOutputType = {
  productId: number
  tagId: number
  _count: ProductTagsCountAggregateOutputType | null
  _avg: ProductTagsAvgAggregateOutputType | null
  _sum: ProductTagsSumAggregateOutputType | null
  _min: ProductTagsMinAggregateOutputType | null
  _max: ProductTagsMaxAggregateOutputType | null
}

type GetProductTagsGroupByPayload<T extends ProductTagsGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ProductTagsGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ProductTagsGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ProductTagsGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ProductTagsGroupByOutputType[P]>
      }
    >
  >



export type ProductTagsWhereInput = {
  AND?: Prisma.ProductTagsWhereInput | Prisma.ProductTagsWhereInput[]
  OR?: Prisma.ProductTagsWhereInput[]
  NOT?: Prisma.ProductTagsWhereInput | Prisma.ProductTagsWhereInput[]
  productId?: Prisma.IntFilter<"ProductTags"> | number
  tagId?: Prisma.IntFilter<"ProductTags"> | number
  product?: Prisma.XOR<Prisma.ProductsScalarRelationFilter, Prisma.ProductsWhereInput>
  tag?: Prisma.XOR<Prisma.TagScalarRelationFilter, Prisma.TagWhereInput>
}

export type ProductTagsOrderByWithRelationInput = {
  productId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
  product?: Prisma.ProductsOrderByWithRelationInput
  tag?: Prisma.TagOrderByWithRelationInput
}

export type ProductTagsWhereUniqueInput = Prisma.AtLeast<{
  productId_tagId?: Prisma.ProductTagsProductIdTagIdCompoundUniqueInput
  AND?: Prisma.ProductTagsWhereInput | Prisma.ProductTagsWhereInput[]
  OR?: Prisma.ProductTagsWhereInput[]
  NOT?: Prisma.ProductTagsWhereInput | Prisma.ProductTagsWhereInput[]
  productId?: Prisma.IntFilter<"ProductTags"> | number
  tagId?: Prisma.IntFilter<"ProductTags"> | number
  product?: Prisma.XOR<Prisma.ProductsScalarRelationFilter, Prisma.ProductsWhereInput>
  tag?: Prisma.XOR<Prisma.TagScalarRelationFilter, Prisma.TagWhereInput>
}, "productId_tagId">

export type ProductTagsOrderByWithAggregationInput = {
  productId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
  _count?: Prisma.ProductTagsCountOrderByAggregateInput
  _avg?: Prisma.ProductTagsAvgOrderByAggregateInput
  _max?: Prisma.ProductTagsMaxOrderByAggregateInput
  _min?: Prisma.ProductTagsMinOrderByAggregateInput
  _sum?: Prisma.ProductTagsSumOrderByAggregateInput
}

export type ProductTagsScalarWhereWithAggregatesInput = {
  AND?: Prisma.ProductTagsScalarWhereWithAggregatesInput | Prisma.ProductTagsScalarWhereWithAggregatesInput[]
  OR?: Prisma.ProductTagsScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ProductTagsScalarWhereWithAggregatesInput | Prisma.ProductTagsScalarWhereWithAggregatesInput[]
  productId?: Prisma.IntWithAggregatesFilter<"ProductTags"> | number
  tagId?: Prisma.IntWithAggregatesFilter<"ProductTags"> | number
}

export type ProductTagsCreateInput = {
  product: Prisma.ProductsCreateNestedOneWithoutTagsInput
  tag: Prisma.TagCreateNestedOneWithoutProductsInput
}

export type ProductTagsUncheckedCreateInput = {
  productId: number
  tagId: number
}

export type ProductTagsUpdateInput = {
  product?: Prisma.ProductsUpdateOneRequiredWithoutTagsNestedInput
  tag?: Prisma.TagUpdateOneRequiredWithoutProductsNestedInput
}

export type ProductTagsUncheckedUpdateInput = {
  productId?: Prisma.IntFieldUpdateOperationsInput | number
  tagId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductTagsCreateManyInput = {
  productId: number
  tagId: number
}

export type ProductTagsUpdateManyMutationInput = {

}

export type ProductTagsUncheckedUpdateManyInput = {
  productId?: Prisma.IntFieldUpdateOperationsInput | number
  tagId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductTagsListRelationFilter = {
  every?: Prisma.ProductTagsWhereInput
  some?: Prisma.ProductTagsWhereInput
  none?: Prisma.ProductTagsWhereInput
}

export type ProductTagsOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ProductTagsProductIdTagIdCompoundUniqueInput = {
  productId: number
  tagId: number
}

export type ProductTagsCountOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
}

export type ProductTagsAvgOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
}

export type ProductTagsMaxOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
}

export type ProductTagsMinOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
}

export type ProductTagsSumOrderByAggregateInput = {
  productId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
}

export type ProductTagsCreateNestedManyWithoutProductInput = {
  create?: Prisma.XOR<Prisma.ProductTagsCreateWithoutProductInput, Prisma.ProductTagsUncheckedCreateWithoutProductInput> | Prisma.ProductTagsCreateWithoutProductInput[] | Prisma.ProductTagsUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.ProductTagsCreateOrConnectWithoutProductInput | Prisma.ProductTagsCreateOrConnectWithoutProductInput[]
  createMany?: Prisma.ProductTagsCreateManyProductInputEnvelope
  connect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
}

export type ProductTagsUncheckedCreateNestedManyWithoutProductInput = {
  create?: Prisma.XOR<Prisma.ProductTagsCreateWithoutProductInput, Prisma.ProductTagsUncheckedCreateWithoutProductInput> | Prisma.ProductTagsCreateWithoutProductInput[] | Prisma.ProductTagsUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.ProductTagsCreateOrConnectWithoutProductInput | Prisma.ProductTagsCreateOrConnectWithoutProductInput[]
  createMany?: Prisma.ProductTagsCreateManyProductInputEnvelope
  connect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
}

export type ProductTagsUpdateManyWithoutProductNestedInput = {
  create?: Prisma.XOR<Prisma.ProductTagsCreateWithoutProductInput, Prisma.ProductTagsUncheckedCreateWithoutProductInput> | Prisma.ProductTagsCreateWithoutProductInput[] | Prisma.ProductTagsUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.ProductTagsCreateOrConnectWithoutProductInput | Prisma.ProductTagsCreateOrConnectWithoutProductInput[]
  upsert?: Prisma.ProductTagsUpsertWithWhereUniqueWithoutProductInput | Prisma.ProductTagsUpsertWithWhereUniqueWithoutProductInput[]
  createMany?: Prisma.ProductTagsCreateManyProductInputEnvelope
  set?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  disconnect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  delete?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  connect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  update?: Prisma.ProductTagsUpdateWithWhereUniqueWithoutProductInput | Prisma.ProductTagsUpdateWithWhereUniqueWithoutProductInput[]
  updateMany?: Prisma.ProductTagsUpdateManyWithWhereWithoutProductInput | Prisma.ProductTagsUpdateManyWithWhereWithoutProductInput[]
  deleteMany?: Prisma.ProductTagsScalarWhereInput | Prisma.ProductTagsScalarWhereInput[]
}

export type ProductTagsUncheckedUpdateManyWithoutProductNestedInput = {
  create?: Prisma.XOR<Prisma.ProductTagsCreateWithoutProductInput, Prisma.ProductTagsUncheckedCreateWithoutProductInput> | Prisma.ProductTagsCreateWithoutProductInput[] | Prisma.ProductTagsUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.ProductTagsCreateOrConnectWithoutProductInput | Prisma.ProductTagsCreateOrConnectWithoutProductInput[]
  upsert?: Prisma.ProductTagsUpsertWithWhereUniqueWithoutProductInput | Prisma.ProductTagsUpsertWithWhereUniqueWithoutProductInput[]
  createMany?: Prisma.ProductTagsCreateManyProductInputEnvelope
  set?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  disconnect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  delete?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  connect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  update?: Prisma.ProductTagsUpdateWithWhereUniqueWithoutProductInput | Prisma.ProductTagsUpdateWithWhereUniqueWithoutProductInput[]
  updateMany?: Prisma.ProductTagsUpdateManyWithWhereWithoutProductInput | Prisma.ProductTagsUpdateManyWithWhereWithoutProductInput[]
  deleteMany?: Prisma.ProductTagsScalarWhereInput | Prisma.ProductTagsScalarWhereInput[]
}

export type ProductTagsCreateNestedManyWithoutTagInput = {
  create?: Prisma.XOR<Prisma.ProductTagsCreateWithoutTagInput, Prisma.ProductTagsUncheckedCreateWithoutTagInput> | Prisma.ProductTagsCreateWithoutTagInput[] | Prisma.ProductTagsUncheckedCreateWithoutTagInput[]
  connectOrCreate?: Prisma.ProductTagsCreateOrConnectWithoutTagInput | Prisma.ProductTagsCreateOrConnectWithoutTagInput[]
  createMany?: Prisma.ProductTagsCreateManyTagInputEnvelope
  connect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
}

export type ProductTagsUncheckedCreateNestedManyWithoutTagInput = {
  create?: Prisma.XOR<Prisma.ProductTagsCreateWithoutTagInput, Prisma.ProductTagsUncheckedCreateWithoutTagInput> | Prisma.ProductTagsCreateWithoutTagInput[] | Prisma.ProductTagsUncheckedCreateWithoutTagInput[]
  connectOrCreate?: Prisma.ProductTagsCreateOrConnectWithoutTagInput | Prisma.ProductTagsCreateOrConnectWithoutTagInput[]
  createMany?: Prisma.ProductTagsCreateManyTagInputEnvelope
  connect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
}

export type ProductTagsUpdateManyWithoutTagNestedInput = {
  create?: Prisma.XOR<Prisma.ProductTagsCreateWithoutTagInput, Prisma.ProductTagsUncheckedCreateWithoutTagInput> | Prisma.ProductTagsCreateWithoutTagInput[] | Prisma.ProductTagsUncheckedCreateWithoutTagInput[]
  connectOrCreate?: Prisma.ProductTagsCreateOrConnectWithoutTagInput | Prisma.ProductTagsCreateOrConnectWithoutTagInput[]
  upsert?: Prisma.ProductTagsUpsertWithWhereUniqueWithoutTagInput | Prisma.ProductTagsUpsertWithWhereUniqueWithoutTagInput[]
  createMany?: Prisma.ProductTagsCreateManyTagInputEnvelope
  set?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  disconnect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  delete?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  connect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  update?: Prisma.ProductTagsUpdateWithWhereUniqueWithoutTagInput | Prisma.ProductTagsUpdateWithWhereUniqueWithoutTagInput[]
  updateMany?: Prisma.ProductTagsUpdateManyWithWhereWithoutTagInput | Prisma.ProductTagsUpdateManyWithWhereWithoutTagInput[]
  deleteMany?: Prisma.ProductTagsScalarWhereInput | Prisma.ProductTagsScalarWhereInput[]
}

export type ProductTagsUncheckedUpdateManyWithoutTagNestedInput = {
  create?: Prisma.XOR<Prisma.ProductTagsCreateWithoutTagInput, Prisma.ProductTagsUncheckedCreateWithoutTagInput> | Prisma.ProductTagsCreateWithoutTagInput[] | Prisma.ProductTagsUncheckedCreateWithoutTagInput[]
  connectOrCreate?: Prisma.ProductTagsCreateOrConnectWithoutTagInput | Prisma.ProductTagsCreateOrConnectWithoutTagInput[]
  upsert?: Prisma.ProductTagsUpsertWithWhereUniqueWithoutTagInput | Prisma.ProductTagsUpsertWithWhereUniqueWithoutTagInput[]
  createMany?: Prisma.ProductTagsCreateManyTagInputEnvelope
  set?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  disconnect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  delete?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  connect?: Prisma.ProductTagsWhereUniqueInput | Prisma.ProductTagsWhereUniqueInput[]
  update?: Prisma.ProductTagsUpdateWithWhereUniqueWithoutTagInput | Prisma.ProductTagsUpdateWithWhereUniqueWithoutTagInput[]
  updateMany?: Prisma.ProductTagsUpdateManyWithWhereWithoutTagInput | Prisma.ProductTagsUpdateManyWithWhereWithoutTagInput[]
  deleteMany?: Prisma.ProductTagsScalarWhereInput | Prisma.ProductTagsScalarWhereInput[]
}

export type ProductTagsCreateWithoutProductInput = {
  tag: Prisma.TagCreateNestedOneWithoutProductsInput
}

export type ProductTagsUncheckedCreateWithoutProductInput = {
  tagId: number
}

export type ProductTagsCreateOrConnectWithoutProductInput = {
  where: Prisma.ProductTagsWhereUniqueInput
  create: Prisma.XOR<Prisma.ProductTagsCreateWithoutProductInput, Prisma.ProductTagsUncheckedCreateWithoutProductInput>
}

export type ProductTagsCreateManyProductInputEnvelope = {
  data: Prisma.ProductTagsCreateManyProductInput | Prisma.ProductTagsCreateManyProductInput[]
  skipDuplicates?: boolean
}

export type ProductTagsUpsertWithWhereUniqueWithoutProductInput = {
  where: Prisma.ProductTagsWhereUniqueInput
  update: Prisma.XOR<Prisma.ProductTagsUpdateWithoutProductInput, Prisma.ProductTagsUncheckedUpdateWithoutProductInput>
  create: Prisma.XOR<Prisma.ProductTagsCreateWithoutProductInput, Prisma.ProductTagsUncheckedCreateWithoutProductInput>
}

export type ProductTagsUpdateWithWhereUniqueWithoutProductInput = {
  where: Prisma.ProductTagsWhereUniqueInput
  data: Prisma.XOR<Prisma.ProductTagsUpdateWithoutProductInput, Prisma.ProductTagsUncheckedUpdateWithoutProductInput>
}

export type ProductTagsUpdateManyWithWhereWithoutProductInput = {
  where: Prisma.ProductTagsScalarWhereInput
  data: Prisma.XOR<Prisma.ProductTagsUpdateManyMutationInput, Prisma.ProductTagsUncheckedUpdateManyWithoutProductInput>
}

export type ProductTagsScalarWhereInput = {
  AND?: Prisma.ProductTagsScalarWhereInput | Prisma.ProductTagsScalarWhereInput[]
  OR?: Prisma.ProductTagsScalarWhereInput[]
  NOT?: Prisma.ProductTagsScalarWhereInput | Prisma.ProductTagsScalarWhereInput[]
  productId?: Prisma.IntFilter<"ProductTags"> | number
  tagId?: Prisma.IntFilter<"ProductTags"> | number
}

export type ProductTagsCreateWithoutTagInput = {
  product: Prisma.ProductsCreateNestedOneWithoutTagsInput
}

export type ProductTagsUncheckedCreateWithoutTagInput = {
  productId: number
}

export type ProductTagsCreateOrConnectWithoutTagInput = {
  where: Prisma.ProductTagsWhereUniqueInput
  create: Prisma.XOR<Prisma.ProductTagsCreateWithoutTagInput, Prisma.ProductTagsUncheckedCreateWithoutTagInput>
}

export type ProductTagsCreateManyTagInputEnvelope = {
  data: Prisma.ProductTagsCreateManyTagInput | Prisma.ProductTagsCreateManyTagInput[]
  skipDuplicates?: boolean
}

export type ProductTagsUpsertWithWhereUniqueWithoutTagInput = {
  where: Prisma.ProductTagsWhereUniqueInput
  update: Prisma.XOR<Prisma.ProductTagsUpdateWithoutTagInput, Prisma.ProductTagsUncheckedUpdateWithoutTagInput>
  create: Prisma.XOR<Prisma.ProductTagsCreateWithoutTagInput, Prisma.ProductTagsUncheckedCreateWithoutTagInput>
}

export type ProductTagsUpdateWithWhereUniqueWithoutTagInput = {
  where: Prisma.ProductTagsWhereUniqueInput
  data: Prisma.XOR<Prisma.ProductTagsUpdateWithoutTagInput, Prisma.ProductTagsUncheckedUpdateWithoutTagInput>
}

export type ProductTagsUpdateManyWithWhereWithoutTagInput = {
  where: Prisma.ProductTagsScalarWhereInput
  data: Prisma.XOR<Prisma.ProductTagsUpdateManyMutationInput, Prisma.ProductTagsUncheckedUpdateManyWithoutTagInput>
}

export type ProductTagsCreateManyProductInput = {
  tagId: number
}

export type ProductTagsUpdateWithoutProductInput = {
  tag?: Prisma.TagUpdateOneRequiredWithoutProductsNestedInput
}

export type ProductTagsUncheckedUpdateWithoutProductInput = {
  tagId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductTagsUncheckedUpdateManyWithoutProductInput = {
  tagId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductTagsCreateManyTagInput = {
  productId: number
}

export type ProductTagsUpdateWithoutTagInput = {
  product?: Prisma.ProductsUpdateOneRequiredWithoutTagsNestedInput
}

export type ProductTagsUncheckedUpdateWithoutTagInput = {
  productId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type ProductTagsUncheckedUpdateManyWithoutTagInput = {
  productId?: Prisma.IntFieldUpdateOperationsInput | number
}



export type ProductTagsSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  productId?: boolean
  tagId?: boolean
  product?: boolean | Prisma.ProductsDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productTags"]>

export type ProductTagsSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  productId?: boolean
  tagId?: boolean
  product?: boolean | Prisma.ProductsDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productTags"]>

export type ProductTagsSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  productId?: boolean
  tagId?: boolean
  product?: boolean | Prisma.ProductsDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productTags"]>

export type ProductTagsSelectScalar = {
  productId?: boolean
  tagId?: boolean
}

export type ProductTagsOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"productId" | "tagId", ExtArgs["result"]["productTags"]>
export type ProductTagsInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  product?: boolean | Prisma.ProductsDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}
export type ProductTagsIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  product?: boolean | Prisma.ProductsDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}
export type ProductTagsIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  product?: boolean | Prisma.ProductsDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}

export type $ProductTagsPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ProductTags"
  objects: {
    product: Prisma.$ProductsPayload<ExtArgs>
    tag: Prisma.$TagPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    productId: number
    tagId: number
  }, ExtArgs["result"]["productTags"]>
  composites: {}
}

export type ProductTagsGetPayload<S extends boolean | null | undefined | ProductTagsDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload, S>

export type ProductTagsCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ProductTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProductTagsCountAggregateInputType | true
  }

export interface ProductTagsDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductTags'], meta: { name: 'ProductTags' } }
  /**
   * Find zero or one ProductTags that matches the filter.
   * @param {ProductTagsFindUniqueArgs} args - Arguments to find a ProductTags
   * @example
   * // Get one ProductTags
   * const productTags = await prisma.productTags.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ProductTagsFindUniqueArgs>(args: Prisma.SelectSubset<T, ProductTagsFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ProductTagsClient<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ProductTags that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ProductTagsFindUniqueOrThrowArgs} args - Arguments to find a ProductTags
   * @example
   * // Get one ProductTags
   * const productTags = await prisma.productTags.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ProductTagsFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ProductTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProductTagsClient<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProductTags that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductTagsFindFirstArgs} args - Arguments to find a ProductTags
   * @example
   * // Get one ProductTags
   * const productTags = await prisma.productTags.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ProductTagsFindFirstArgs>(args?: Prisma.SelectSubset<T, ProductTagsFindFirstArgs<ExtArgs>>): Prisma.Prisma__ProductTagsClient<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProductTags that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductTagsFindFirstOrThrowArgs} args - Arguments to find a ProductTags
   * @example
   * // Get one ProductTags
   * const productTags = await prisma.productTags.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ProductTagsFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ProductTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProductTagsClient<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ProductTags that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductTagsFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ProductTags
   * const productTags = await prisma.productTags.findMany()
   * 
   * // Get first 10 ProductTags
   * const productTags = await prisma.productTags.findMany({ take: 10 })
   * 
   * // Only select the `productId`
   * const productTagsWithProductIdOnly = await prisma.productTags.findMany({ select: { productId: true } })
   * 
   */
  findMany<T extends ProductTagsFindManyArgs>(args?: Prisma.SelectSubset<T, ProductTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ProductTags.
   * @param {ProductTagsCreateArgs} args - Arguments to create a ProductTags.
   * @example
   * // Create one ProductTags
   * const ProductTags = await prisma.productTags.create({
   *   data: {
   *     // ... data to create a ProductTags
   *   }
   * })
   * 
   */
  create<T extends ProductTagsCreateArgs>(args: Prisma.SelectSubset<T, ProductTagsCreateArgs<ExtArgs>>): Prisma.Prisma__ProductTagsClient<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ProductTags.
   * @param {ProductTagsCreateManyArgs} args - Arguments to create many ProductTags.
   * @example
   * // Create many ProductTags
   * const productTags = await prisma.productTags.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ProductTagsCreateManyArgs>(args?: Prisma.SelectSubset<T, ProductTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ProductTags and returns the data saved in the database.
   * @param {ProductTagsCreateManyAndReturnArgs} args - Arguments to create many ProductTags.
   * @example
   * // Create many ProductTags
   * const productTags = await prisma.productTags.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ProductTags and only return the `productId`
   * const productTagsWithProductIdOnly = await prisma.productTags.createManyAndReturn({
   *   select: { productId: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ProductTagsCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ProductTagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ProductTags.
   * @param {ProductTagsDeleteArgs} args - Arguments to delete one ProductTags.
   * @example
   * // Delete one ProductTags
   * const ProductTags = await prisma.productTags.delete({
   *   where: {
   *     // ... filter to delete one ProductTags
   *   }
   * })
   * 
   */
  delete<T extends ProductTagsDeleteArgs>(args: Prisma.SelectSubset<T, ProductTagsDeleteArgs<ExtArgs>>): Prisma.Prisma__ProductTagsClient<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ProductTags.
   * @param {ProductTagsUpdateArgs} args - Arguments to update one ProductTags.
   * @example
   * // Update one ProductTags
   * const productTags = await prisma.productTags.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ProductTagsUpdateArgs>(args: Prisma.SelectSubset<T, ProductTagsUpdateArgs<ExtArgs>>): Prisma.Prisma__ProductTagsClient<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ProductTags.
   * @param {ProductTagsDeleteManyArgs} args - Arguments to filter ProductTags to delete.
   * @example
   * // Delete a few ProductTags
   * const { count } = await prisma.productTags.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ProductTagsDeleteManyArgs>(args?: Prisma.SelectSubset<T, ProductTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProductTags.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductTagsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ProductTags
   * const productTags = await prisma.productTags.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ProductTagsUpdateManyArgs>(args: Prisma.SelectSubset<T, ProductTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProductTags and returns the data updated in the database.
   * @param {ProductTagsUpdateManyAndReturnArgs} args - Arguments to update many ProductTags.
   * @example
   * // Update many ProductTags
   * const productTags = await prisma.productTags.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ProductTags and only return the `productId`
   * const productTagsWithProductIdOnly = await prisma.productTags.updateManyAndReturn({
   *   select: { productId: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ProductTagsUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ProductTagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ProductTags.
   * @param {ProductTagsUpsertArgs} args - Arguments to update or create a ProductTags.
   * @example
   * // Update or create a ProductTags
   * const productTags = await prisma.productTags.upsert({
   *   create: {
   *     // ... data to create a ProductTags
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ProductTags we want to update
   *   }
   * })
   */
  upsert<T extends ProductTagsUpsertArgs>(args: Prisma.SelectSubset<T, ProductTagsUpsertArgs<ExtArgs>>): Prisma.Prisma__ProductTagsClient<runtime.Types.Result.GetResult<Prisma.$ProductTagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ProductTags.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductTagsCountArgs} args - Arguments to filter ProductTags to count.
   * @example
   * // Count the number of ProductTags
   * const count = await prisma.productTags.count({
   *   where: {
   *     // ... the filter for the ProductTags we want to count
   *   }
   * })
  **/
  count<T extends ProductTagsCountArgs>(
    args?: Prisma.Subset<T, ProductTagsCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ProductTagsCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ProductTags.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ProductTagsAggregateArgs>(args: Prisma.Subset<T, ProductTagsAggregateArgs>): Prisma.PrismaPromise<GetProductTagsAggregateType<T>>

  /**
   * Group by ProductTags.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductTagsGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ProductTagsGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ProductTagsGroupByArgs['orderBy'] }
      : { orderBy?: ProductTagsGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ProductTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ProductTags model
 */
readonly fields: ProductTagsFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ProductTags.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ProductTagsClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  product<T extends Prisma.ProductsDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProductsDefaultArgs<ExtArgs>>): Prisma.Prisma__ProductsClient<runtime.Types.Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  tag<T extends Prisma.TagDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TagDefaultArgs<ExtArgs>>): Prisma.Prisma__TagClient<runtime.Types.Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ProductTags model
 */
export interface ProductTagsFieldRefs {
  readonly productId: Prisma.FieldRef<"ProductTags", 'Int'>
  readonly tagId: Prisma.FieldRef<"ProductTags", 'Int'>
}
    

// Custom InputTypes
/**
 * ProductTags findUnique
 */
export type ProductTagsFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * Filter, which ProductTags to fetch.
   */
  where: Prisma.ProductTagsWhereUniqueInput
}

/**
 * ProductTags findUniqueOrThrow
 */
export type ProductTagsFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * Filter, which ProductTags to fetch.
   */
  where: Prisma.ProductTagsWhereUniqueInput
}

/**
 * ProductTags findFirst
 */
export type ProductTagsFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * Filter, which ProductTags to fetch.
   */
  where?: Prisma.ProductTagsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductTags to fetch.
   */
  orderBy?: Prisma.ProductTagsOrderByWithRelationInput | Prisma.ProductTagsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProductTags.
   */
  cursor?: Prisma.ProductTagsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductTags from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductTags.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProductTags.
   */
  distinct?: Prisma.ProductTagsScalarFieldEnum | Prisma.ProductTagsScalarFieldEnum[]
}

/**
 * ProductTags findFirstOrThrow
 */
export type ProductTagsFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * Filter, which ProductTags to fetch.
   */
  where?: Prisma.ProductTagsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductTags to fetch.
   */
  orderBy?: Prisma.ProductTagsOrderByWithRelationInput | Prisma.ProductTagsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProductTags.
   */
  cursor?: Prisma.ProductTagsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductTags from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductTags.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProductTags.
   */
  distinct?: Prisma.ProductTagsScalarFieldEnum | Prisma.ProductTagsScalarFieldEnum[]
}

/**
 * ProductTags findMany
 */
export type ProductTagsFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * Filter, which ProductTags to fetch.
   */
  where?: Prisma.ProductTagsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductTags to fetch.
   */
  orderBy?: Prisma.ProductTagsOrderByWithRelationInput | Prisma.ProductTagsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ProductTags.
   */
  cursor?: Prisma.ProductTagsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductTags from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductTags.
   */
  skip?: number
  distinct?: Prisma.ProductTagsScalarFieldEnum | Prisma.ProductTagsScalarFieldEnum[]
}

/**
 * ProductTags create
 */
export type ProductTagsCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * The data needed to create a ProductTags.
   */
  data: Prisma.XOR<Prisma.ProductTagsCreateInput, Prisma.ProductTagsUncheckedCreateInput>
}

/**
 * ProductTags createMany
 */
export type ProductTagsCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ProductTags.
   */
  data: Prisma.ProductTagsCreateManyInput | Prisma.ProductTagsCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ProductTags createManyAndReturn
 */
export type ProductTagsCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * The data used to create many ProductTags.
   */
  data: Prisma.ProductTagsCreateManyInput | Prisma.ProductTagsCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ProductTags update
 */
export type ProductTagsUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * The data needed to update a ProductTags.
   */
  data: Prisma.XOR<Prisma.ProductTagsUpdateInput, Prisma.ProductTagsUncheckedUpdateInput>
  /**
   * Choose, which ProductTags to update.
   */
  where: Prisma.ProductTagsWhereUniqueInput
}

/**
 * ProductTags updateMany
 */
export type ProductTagsUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ProductTags.
   */
  data: Prisma.XOR<Prisma.ProductTagsUpdateManyMutationInput, Prisma.ProductTagsUncheckedUpdateManyInput>
  /**
   * Filter which ProductTags to update
   */
  where?: Prisma.ProductTagsWhereInput
  /**
   * Limit how many ProductTags to update.
   */
  limit?: number
}

/**
 * ProductTags updateManyAndReturn
 */
export type ProductTagsUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * The data used to update ProductTags.
   */
  data: Prisma.XOR<Prisma.ProductTagsUpdateManyMutationInput, Prisma.ProductTagsUncheckedUpdateManyInput>
  /**
   * Filter which ProductTags to update
   */
  where?: Prisma.ProductTagsWhereInput
  /**
   * Limit how many ProductTags to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ProductTags upsert
 */
export type ProductTagsUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * The filter to search for the ProductTags to update in case it exists.
   */
  where: Prisma.ProductTagsWhereUniqueInput
  /**
   * In case the ProductTags found by the `where` argument doesn't exist, create a new ProductTags with this data.
   */
  create: Prisma.XOR<Prisma.ProductTagsCreateInput, Prisma.ProductTagsUncheckedCreateInput>
  /**
   * In case the ProductTags was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ProductTagsUpdateInput, Prisma.ProductTagsUncheckedUpdateInput>
}

/**
 * ProductTags delete
 */
export type ProductTagsDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
  /**
   * Filter which ProductTags to delete.
   */
  where: Prisma.ProductTagsWhereUniqueInput
}

/**
 * ProductTags deleteMany
 */
export type ProductTagsDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProductTags to delete
   */
  where?: Prisma.ProductTagsWhereInput
  /**
   * Limit how many ProductTags to delete.
   */
  limit?: number
}

/**
 * ProductTags without action
 */
export type ProductTagsDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductTags
   */
  select?: Prisma.ProductTagsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductTags
   */
  omit?: Prisma.ProductTagsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductTagsInclude<ExtArgs> | null
}
